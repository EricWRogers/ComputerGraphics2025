#include "utils.h"
#include <assimp/scene.h>
#include <assimp/postprocess.h>
#include <assimp/Importer.hpp>
#include <unordered_map>
#include <SDL.h>
#include "glad.h"
#include <cstdlib>
#include "stb_image.h"


/*
opengl skeletal animation demo
*/


const char* vertexShaderSource = R"(
	#version 440 core
	layout (location = 0) in vec3 position; 
	layout (location = 1) in vec3 normal;
	layout (location = 2) in vec2 uv;
	layout (location = 3) in vec4 boneIds;
	layout (location = 4) in vec4 boneWeights;

	out vec2 tex_cord;
	out vec3 v_normal;
	out vec3 v_pos;
	out vec4 bw;

	uniform mat4 bone_transforms[50];
	uniform mat4 view_projection_matrix;
	uniform mat4 model_matrix;

	void main()
	{
		bw = vec4(0);
		if(int(boneIds.x) == 1)
		bw.z = boneIds.x;
		//boneWeights = normalize(boneWeights);
		mat4 boneTransform  =  mat4(0.0);
		boneTransform  +=    bone_transforms[int(boneIds.x)] * boneWeights.x;
		boneTransform  +=    bone_transforms[int(boneIds.y)] * boneWeights.y;
		boneTransform  +=    bone_transforms[int(boneIds.z)] * boneWeights.z;
		boneTransform  +=    bone_transforms[int(boneIds.w)] * boneWeights.w;
		vec4 pos =boneTransform * vec4(position, 1.0);
		gl_Position = view_projection_matrix * model_matrix * pos;
		v_pos = vec3(model_matrix * boneTransform * pos);
		tex_cord = uv;
		v_normal = mat3(transpose(inverse(model_matrix * boneTransform))) * normal;
		v_normal = normalize(v_normal);
	}
)";

const char* fragmentShaderSource = R"(
	#version 440 core

	in vec2 tex_cord;
	in vec3 v_normal;
	in vec3 v_pos;
	in vec4 bw;
	out vec4 color;

	uniform sampler2D diff_texture;

	vec3 lightPos = vec3(0.2, 1.0, -3.0);
	
	void main()
	{
		vec3 lightDir = normalize(lightPos - v_pos);
		float diff = max(dot(v_normal, lightDir), 0.2);
		vec3 dCol = diff * texture(diff_texture, tex_cord).rgb; 
		color = vec4(dCol, 1);
	}
)";


int main(int argc, char ** argv) {

	//init
	int windowWidth, windowHeight;
	SDL_Window* window = initWindow(windowWidth, windowHeight);
	bool isRunning = true;

	//load model file
	Assimp::Importer importer;
	const char* filePath = "assets/Astronaut.glb";
	const aiScene* scene = importer.ReadFile(filePath, aiProcess_Triangulate | aiProcess_FlipUVs | aiProcess_GenSmoothNormals);

	if (!scene || scene->mFlags & AI_SCENE_FLAGS_INCOMPLETE || !scene->mRootNode) {
		std::cout << "ERROR::ASSIMP::" << importer.GetErrorString() << std::endl;
	}
	aiMesh* mesh = scene->mMeshes[0];

	std::vector<Vertex> vertices = {};
	std::vector<uint> indices = {};
	uint boneCount = 0;
	Animation animation;
	uint vao = 0;
	Bone skeleton;
	uint diffuseTexture;
	
	//as the name suggests just inverse the global transform
	glm::mat4 globalInverseTransform = assimpToGlmMatrix(scene->mRootNode->mTransformation);
	globalInverseTransform = glm::inverse(globalInverseTransform);
	

	loadModel(scene, mesh, vertices, indices, skeleton, boneCount);
	loadAnimation(scene, animation);

	vao = createVertexArray(vertices, indices);
	diffuseTexture = createTexture("assets/man/diffuse.png");

	glm::mat4 identity(1.0);

	//currentPose is held in this vector and uploaded to gpu as a matrix array uniform
	std::vector<glm::mat4> currentPose = {};
	currentPose.resize(boneCount, identity); // use this for no animation

	uint shader = createShader(vertexShaderSource, fragmentShaderSource);

	//get all shader uniform locations
	uint viewProjectionMatrixLocation = glGetUniformLocation(shader, "view_projection_matrix");
	uint modelMatrixLocation = glGetUniformLocation(shader, "model_matrix");
	uint boneMatricesLocation = glGetUniformLocation(shader, "bone_transforms");
	uint textureLocation = glGetUniformLocation(shader, "diff_texture");



	// initialize projection view and model matrix
	glm::mat4 projectionMatrix = glm::perspective(75.0f, (float)windowWidth / windowHeight, 0.01f, 100.0f);

	glm::mat4 viewMatrix = glm::lookAt(glm::vec3(0.0f, 0.2f, -5.0f)
		, glm::vec3(0.0f, .0f, 0.0f),
		glm::vec3(0, 1, 0));
	glm::mat4 viewProjectionMatrix = projectionMatrix * viewMatrix;

	glm::mat4 modelMatrix(1.0f);
	modelMatrix = glm::translate(modelMatrix, glm::vec3(0.0f, 1.0f, 0.0f));
	modelMatrix = glm::scale(modelMatrix, glm::vec3(.2f, .2f, .2f));


	//update loop
	while (isRunning) {
		SDL_Event ev;
		while (SDL_PollEvent(&ev)) {
			if (ev.type == SDL_QUIT)
				isRunning = false;
		}

		float elapsedTime = (float)SDL_GetTicks() / 1000;

		float dAngle = elapsedTime * 0.002;
		//modelMatrix = glm::rotate(modelMatrix, dAngle, glm::vec3(0, 1, 0));

		getPose(animation, skeleton, elapsedTime, currentPose, identity, globalInverseTransform);

		std::cout << "pose" << std::endl;

		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		glUseProgram(shader);
		glUniformMatrix4fv(viewProjectionMatrixLocation, 1, GL_FALSE, glm::value_ptr(viewProjectionMatrix));
		glUniformMatrix4fv(modelMatrixLocation, 1, GL_FALSE, glm::value_ptr(modelMatrix));
		glUniformMatrix4fv(boneMatricesLocation,boneCount, GL_FALSE, glm::value_ptr(currentPose[0]));

		glBindVertexArray(vao);
		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, diffuseTexture);
		glUniform1i(textureLocation, 0);

		glDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_INT, 0);

		SDL_GL_SwapWindow(window);
	}

	//cleanup
	SDL_GLContext context =  SDL_GL_GetCurrentContext();
	SDL_GL_DeleteContext(context);
	SDL_DestroyWindow(window);
	SDL_Quit();

	return 0;
}